개발관련버전
java 21
springframework boot 3.4.3
swagger 3
mysql-8.4.4
mongodb-8
zookeeper-3.8
kafka-3.5.2
kafka-ui-0.7.2

설계 원칙
1. 객체지향프로그래밍 (Object Oriented Programming) 설계 원칙
   소프트웨어를 객체(object)라는 단위로 분리하여 각 객체가 데이터(속성)와 그 데이터를 처리하는 메소드(행동)를 포함하도록 설계하는 방식입니다.
   -캡슐화 (Encapsulation):
   각 객체는 자신의 데이터를 외부로부터 보호하며, 필요한 경우에만 공개된 인터페이스를 통해 접근하도록 설계되었습니다. 
   이를 통해 객체 내부의 구현 세부사항은 숨기고, 명확한 계약(인터페이스)을 통해 상호작용함으로써 코드의 안정성과 유지보수성을 높입니다.

   -추상화 (Abstraction):
   복잡한 시스템을 단순화하기 위해 공통된 특성이나 기능을 추출하여 인터페이스 또는 추상 클래스로 정의합니다.
   
   -상속 (Inheritance):
   기존 클래스의 특성을 물려받아 새로운 클래스를 생성하는 상속 개념을 활용하여, 코드의 재사용성과 일관성을 높입니다. 
   공통 기능을 상위 클래스에 정의하고, 이를 기반으로 하위 클래스가 특화된 기능을 추가하는 방식으로 구현되어, 중복 코드 제거와 유지보수가 용이합니다.
   
   -다형성 (Polymorphism):
   동일한 인터페이스나 부모 클래스를 통해 다양한 객체들이 상호교환적으로 사용될 수 있도록 합니다. 
   프로그램은 실행 시점에 구체적인 객체의 유형에 의존하지 않고, 인터페이스에 정의된 메소드만 호출하여 유연하게 동작할 수 있습니다.
   
   -SOLID 원칙:
   각 모듈이 하나의 역할에 집중하고 확장에 유연하도록 설계되었습니다.
   단일 책임 원칙 (SRP): 각 클래스는 하나의 책임만 가지며, 해당 책임 변경의 이유도 하나로 제한합니다.
   개방-폐쇄 원칙 (OCP): 클래스는 확장에는 열려 있으면서 변경에는 닫혀 있도록 설계합니다.
   리스코프 치환 원칙 (LSP): 상위 타입의 객체를 하위 타입의 객체로 대체해도 프로그램의 기능이 올바르게 동작해야 합니다.
   인터페이스 분리 원칙 (ISP): 클라이언트는 자신이 사용하지 않는 메소드에 의존하지 않도록 인터페이스를 작게 분리합니다.
   의존성 역전 원칙 (DIP): 고수준 모듈이 저수준 모듈에 의존하지 않고, 추상화에 의존하도록 설계되어 있습니다.

2.모듈화 및 계층화
   프로젝트는 기능별로 모듈이 명확하게 분리되어 있으며, 데이터 접근, 비즈니스 로직, 사용자 인터페이스 등 각 계층이 독립적으로 구성되어 있습니다.
   각 모듈의 변경이 다른 모듈에 미치는 영향을 최소화하여, 코드 유지보수와 확장이 용이하도록 돕습니다.

3.DRY (Don't Repeat Yourself)
   중복 코드를 제거하기 위해 공통 기능을 별도의 유틸리티 함수나 모듈로 분리하여 재사용합니다.
   코드 일관성을 유지하고, 유지보수 시 변경해야 할 부분을 최소화함으로써 버그 발생 가능성을 낮춥니다.

4.KISS (Keep It Simple, Stupid)
   복잡한 로직은 최대한 단순하게 구현하며, 각 기능은 명확한 입력과 출력을 갖도록 설계되었습니다.
   가독성을 높이고, 시스템 유지보수 및 확장이 용이하도록 설계되어 전체 개발 생산성을 향상시킵니다.

4. 클린 아키텍처 (Clean Architecture)
   비즈니스 규칙과 애플리케이션의 핵심 로직을 외부 구현 세부사항(프레임워크, 데이터베이스, UI 등)과 철저히 분리하는 설계 접근 방식입니다.
   -계층 분리: 
   시스템을 내부와 외부 계층으로 나누고, 내부 계층(비즈니스 로직, 도메인 모델)은 외부 계층(데이터베이스, UI, 프레임워크 등)의 
   변화에 영향을 받지 않도록 설계합니다.
   
   -의존성 역전: 높은 수준의 모듈은 낮은 수준의 모듈에 의존하지 않고, 모두 추상화에 의존합니다. 이는 인터페이스나 추상 클래스를 통해 구현되며,
   결과적으로 비즈니스 로직의 독립성을 보장합니다.
   테스트 및 유지보수 용이성: 계층간 의존성이 낮아지므로, 각 계층을 개별적으로 테스트하고 수정할 수 있습니다.
   비즈니스 로직이 외부 변화에 독립적이게 되어 시스템 확장, 변경 및 테스트가 용이해집니다.
   새로운 기술 도입이나 외부 컴포넌트 변경 시 핵심 로직에 영향을 주지 않으므로, 장기적인 유지보수성과 확장성이 크게 향상됩니다.

5. 이벤트 주도 설계 (Event Driven Design)
   시스템 설계 시 이벤트를 중심으로 시스템의 흐름과 데이터 변화를 모델링하는 방법론입니다.
   -이벤트 중심 모델링: 시스템 내의 모든 상태 변화와 데이터 처리를 이벤트로 추상화하여, 이벤트 발생, 전파, 처리 과정을 명확히 설계합니다.
   
   -비동기 프로세스 관리: 이벤트를 통해 비동기적으로 데이터를 처리함으로써, 시스템 구성 요소들이 독립적으로 반응할 수 있도록 합니다.
   
   -명확한 이벤트 흐름: 이벤트의 흐름과 처리 로직을 명확하게 문서화하여, 복잡한 비동기 로직을 쉽게 이해하고 관리할 수 있습니다.
   
   시스템의 유연성과 확장성이 향상되며, 이벤트 흐름을 명확하게 파악함으로써 비동기 프로세스와 실시간 데이터 처리를 효과적으로 구현할 수 있습니다.

6. 도메인 주도 설계 (Domain-Driven Design)
   설명:
   복잡한 도메인 문제를 해결하기 위해 도메인 전문가와 협업하여 도메인의 핵심 개념, 규칙, 프로세스를 중심으로 소프트웨어를 설계하는 방법론입니다.
   -도메인 모델: 비즈니스 도메인의 핵심 개념과 규칙을 코드에 반영한 모델을 구축합니다.
   
   -유비쿼터스 언어: 개발자와 도메인 전문가가 공통의 언어로 소통할 수 있도록 하여, 요구사항의 일관성과 이해도를 높입니다.

   -바운디드 컨텍스트: 도메인 내에서 서로 다른 하위 시스템이나 영역을 명확히 구분하여, 복잡성을 관리합니다.
   
   시스템의 도메인 복잡성을 효과적으로 관리하고, 비즈니스 요구사항에 밀접하게 부합하는 모델을 구축하여 코드와 도메인 지식의 일관성을 유지할 수 있습니다.
   DTO -> DOMAIN -> ENTITY 구조적용
   
7. 트랜잭션 아웃박스 패턴 (Transaction Outbox Pattern)
   데이터베이스 트랜잭션과 이벤트 발행을 하나의 트랜잭션 내에서 함께 처리하는 설계 패턴입니다.
   동일 트랜잭션 처리: 데이터 변경과 동시에 발생하는 이벤트를 동일한 트랜잭션 안에서 처리하여, 데이터와 이벤트 간의 일관성을 보장합니다.
   임시 저장소 사용: 이벤트는 데이터베이스 내의 'outbox' 테이블에 저장된 후, 별도의 프로세스가 이를 읽어 외부 시스템에 안전하게 전파합니다.
   오류 복구: 시스템 장애가 발생하더라도, 저장된 outbox 항목을 통해 이벤트가 손실되지 않고 최종적으로 전파될 수 있도록 합니다.
   데이터베이스와 외부 시스템 간의 데이터 일관성을 보장하며, 분산 시스템에서 발생할 수 있는 트랜잭션 관리의 복잡성을 줄입니다. 
   이를 통해 시스템 신뢰성이 향상되고, 이벤트 손실 없이 안정적인 통합을 구현할 수 있습니다.

8. 롬복 (Lombok)
   Java 개발 환경에서 반복되는 보일러플레이트 코드를 자동 생성해주는 라이브러리입니다.
   - 자동 코드 생성: 
   getter, setter, 생성자, equals, hashCode, toString 등 기본 메서드를 어노테이션을 통해 자동으로 생성하여 코드의 간결성을 유지합니다.
   
   - 코드 가독성 향상: 
   불필요한 코드가 줄어들어 클래스의 핵심 로직이 더 명확하게 드러납니다.
   
   - 개발 효율성 증대: 
   개발자가 반복적인 작업에 소요되는 시간을 줄여, 비즈니스 로직 구현에 집중할 수 있도록 돕습니다.

   코드의 간결성이 높아지고 유지보수가 용이해지며, 개발 생산성이 향상됩니다. 또한, 코드의 중복이 줄어들어 버그 발생 가능성이 낮아지고, 
   가독성이 개선되어 협업에 유리한 환경을 제공합니다.

9. Builder Pattern (빌더 패턴)
   Builder Pattern(빌더 패턴)은 복잡한 객체의 생성 과정을 단계별로 명확하게 분리하여 처리하는 생성 패턴입니다.
   - 단계적 객체 생성: 객체의 생성 과정에서 필요한 매개변수를 단계적으로 설정할 수 있어, 복잡한 초기화 로직을 단순화합니다.
   - 유연한 객체 구성: 다양한 선택적 속성을 조합하여 객체를 생성할 수 있으며, 가독성이 높은 플루언트 인터페이스를 제공합니다.
   - 불변 객체 지원: 객체 생성 후 변경이 불가능한 불변 객체를 쉽게 생성할 수 있어, 안정성을 높입니다.

   객체 생성 과정이 명확해져 코드의 가독성과 유지보수성이 개선되며, 복잡한 객체 구성 시 발생할 수 있는 오류를 줄여줍니다. 또한, 
   유연한 객체 구성 방식을 통해 다양한 시나리오에 대응할 수 있어, 확장성이 높아집니다.

10. CQRS (Command Query Responsibility Segregation)
   명령과 조회를 분리하여 각각을 위한 모델을 사용하는 패턴입니다.
   -명령과 조회 분리: 명령(데이터 변경)과 조회(데이터 조회)를 위한 모델을 분리하여, 서로 다른 요구사항에 맞게 최적화된 모델을 사용합니다.
   -성능 최적화: 명령과 조회를 분리함으로써, 각 요구사항에 맞게 데이터 저장소, 캐싱, 인덱싱 등을 최적화할 수 있습니다.
   -확장성 향상: 명령과 조회를 분리하면 각각의 모델을 독립적으로 확장할 수 있어, 시스템의 확장성이 향상됩니다. 
   
   명령과 조회를 분리함으로써 서로 다른 요구사항에 맞게 최적화된 모델을 사용할 수 있어, 성능과 확장성을 향상시킬 수 있습니다. 
   또한, 명령과 조회의 복잡성을 분리함으로써 코드의 가독성과 유지보수성이 개선되며, 시스템의 유연성이 높아집니다. 
   
   Command : mysql(JPA), Query : mongodb
   Command, Query 동기화는 local 프로필에서 @Scheduled사용, dev 프로필에서 카프카사용

11. 장애대비 mysql master/slave 구성, mongodb Replica Set 구성

12. RESTful API
    HTTP 프로토콜을 기반으로 리소스 중심의 데이터를 클라이언트와 교환하기 위한 설계 원칙입니다.
    자원 기반 접근: URI를 통해 리소스를 식별하고, HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용하여 리소스에 대한 CRUD 작업을 수행합니다.
    
    -무상태성 (Stateless):
    서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리됩니다. 
    
    -캐시 가능성 (Cacheable): API 응답은 HTTP 캐싱 헤더(Cache-Control, ETag 등)를 활용하여 캐시될 수 있습니다. 
    이를 통해 네트워크 부하를 줄이고, 응답 속도를 개선합니다.
    
    -일관된 인터페이스 (Uniform Interface):
    모든 상호작용은 표준화된 HTTP 프로토콜과 JSON 또는 XML과 같은 표준 포맷을 통해 이루어집니다.
    또한, HATEOAS 원칙을 적용하여 응답 내에 다음에 수행할 수 있는 작업(링크)을 포함함으로써
    클라이언트가 동적으로 API를 탐색할 수 있도록 지원합니다. 
    
    -계층화된 시스템 (Layered System):
    API 서버는 중간 프록시, 로드 밸런서 등 여러 계층을 통해 클라이언트와 통신할 수 있어, 보안 및 확장성을 높입니다.
    
14. Mapper사용 빌더패던사용해서 구현

비즈니스흐름
API -> 전송DTO -> DOMAIN -> 로직실행에 필요한 입력값 확인 후 UUID 리턴 -> 복잡한 비즈니스 로직 비동기수행
